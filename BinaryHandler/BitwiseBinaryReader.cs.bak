using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace D2SLib2.BinaryHandler
{
    public class BitwiseBinaryReader
    {
        public byte[] byteArray { get; private set; }
        private int bytePosition;
        private int bitPosition;

        public BitwiseBinaryReader(string filePath)
        {
            // Load the whole file into memory so it's not locked
            byteArray = File.ReadAllBytes(filePath);

            // Initialize positions
            bytePosition = 0;
            bitPosition = 0;
        }

        public BitwiseBinaryReader(byte[] data)
        {
            // Load the whole file into memory so it's not locked
            byteArray = data;

            // Initialize positions
            bytePosition = 0;
            bitPosition = 0;
        }

        public int BytePosition
        {
            get => bytePosition;
            set
            {
                if (value < 0 || value >= byteArray.Length)
                {
                    throw new ArgumentOutOfRangeException("Invalid byte position");
                }
                bytePosition = value;
            }
        }

        public int BitPosition
        {
            get => bitPosition;
            set
            {
                if (value < 0 || value >= (byteArray.Length * 8))
                {
                    throw new ArgumentOutOfRangeException("Invalid bit position");
                }
                bitPosition = value;
            }
        }

        public void SetBytePosition(int bytePos)
        {
            BytePosition = bytePos;
            BitPosition = bytePos * 8;
        }

        public void SetBitPosition(int bitPos)
        {
            BitPosition = bitPos;
            BytePosition = bitPos / 8;
        }

        public int ReadInt32()
        {
            if (bytePosition + 4 > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            int result = BitConverter.ToInt32(byteArray, bytePosition);
            bytePosition += 4;
            bitPosition += 32;
            return result;
        }

        public uint ReadUInt32()
        {
            if (bytePosition + 4 > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            uint result = BitConverter.ToUInt32(byteArray, bytePosition);
            bytePosition += 4;
            bitPosition += 32;
            return result;
        }

        public short ReadInt16()
        {
            if (bytePosition + 2 > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            short result = BitConverter.ToInt16(byteArray, bytePosition);
            bytePosition += 2;
            bitPosition += 16;
            return result;
        }

        public ushort ReadUInt16()
        {
            if (bytePosition + 2 > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            ushort result = BitConverter.ToUInt16(byteArray, bytePosition);
            bytePosition += 2;
            bitPosition += 16;
            return result;
        }

        public string ReadString(int length)
        {
            if (bytePosition + length > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            string result = System.Text.Encoding.UTF8.GetString(byteArray, bytePosition, length);
            bytePosition += length;
            bitPosition += length * 8;
            return result;
        }

        public byte[] ReadBytes(int length)
        {
            if (bytePosition + length > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            byte[] result = new byte[length];
            Array.Copy(byteArray, bytePosition, result, 0, length);
            bytePosition += length;
            bitPosition += length * 8;
            return result;
        }

        public byte ReadByte()
        {
            if (bytePosition >= byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            byte result = byteArray[bytePosition];
            bytePosition += 1;
            bitPosition += 8;
            return result;
        }

        public byte[] PeekBytes(int length)
        {
            if (bytePosition + length > byteArray.Length)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            byte[] result = new byte[length];
            Array.Copy(byteArray, bytePosition, result, 0, length);
            return result;
        }

        public bool[] ReadBits(int length)
        {
            if (bitPosition + length > byteArray.Length * 8)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            bool[] result = new bool[length];
            int bitsRead = 0;

            while (bitsRead < length)
            {
                int remainingBitsInCurrentByte = 8 - bitPosition % 8;
                int bitsToRead = Math.Min(remainingBitsInCurrentByte, length - bitsRead);

                for (int i = 0; i < bitsToRead; i++)
                {
                    result[bitsRead + i] = (byteArray[bytePosition] & (1 << (bitPosition % 8 + i))) != 0;
                }

                bitsRead += bitsToRead;
                bitPosition += bitsToRead;

                if (bitPosition % 8 == 0)
                {
                    bytePosition++;
                }
            }

            return result;
        }

        public bool ReadBit()
        {
            if (bitPosition >= byteArray.Length * 8)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            bool result = (byteArray[bytePosition] & (1 << (bitPosition % 8))) != 0;

            bitPosition++;

            if (bitPosition % 8 == 0)
            {
                bytePosition++;
            }

            return result;
        }

        public bool[] PeekBits(int length)
        {
            int tempBitPosition = bitPosition;
            int tempBytePosition = bytePosition;

            if (tempBitPosition + length > byteArray.Length * 8)
                throw new ArgumentOutOfRangeException("Cannot read beyond end of array");

            bool[] result = new bool[length];
            int bitsRead = 0;

            while (bitsRead < length)
            {
                int remainingBitsInCurrentByte = 8 - tempBitPosition % 8;
                int bitsToRead = Math.Min(remainingBitsInCurrentByte, length - bitsRead);

                for (int i = 0; i < bitsToRead; i++)
                {
                    result[bitsRead + i] = (byteArray[tempBytePosition] & (1 << (tempBitPosition % 8 + i))) != 0;
                }

                bitsRead += bitsToRead;
                tempBitPosition += bitsToRead;

                if (tempBitPosition % 8 == 0)
                {
                    tempBytePosition++;
                }
            }

            // bitPosition and bytePosition remain unchanged
            return result;
        }

        public void Align() => BitPosition = (BitPosition + 7) & ~7;
    }

    public static class BitArrayExtensions
    {
        public static byte ToByte(this bool[] a)
        {
            return (byte)a.Select((b, i) => b ? 1 << i : 0).Sum();
        }

        public static byte[] ToBytes(this bool[] a)
        {
            int numBytes = (a.Length + 7) / 8; // Calculate total bytes needed
            byte[] result = new byte[numBytes];

            for (int i = 0; i < a.Length; i++)
            {
                if (a[i])
                    result[i / 8] |= (byte)(1 << (i % 8));
            }

            return result;
        }

        public static UInt16 ToUInt16(this bool[] a)
        {
            return (UInt16)a.Select((b, i) => b ? 1 << i : 0).Sum();
        }

        public static UInt32 ToUInt32(this bool[] a)
        {
            return (UInt32)a.Select((b, i) => b ? 1 << i : 0).Sum();
        }

        public static UInt64 ToUInt64(this bool[] a)
        {
            return (UInt64)a.Select((b, i) => b ? 1 << i : 0).Sum();
        }

        public static string To_String(this bool[] a, int bitsPerChar = 8)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < a.Length; i += bitsPerChar)
            {
                byte b = 0;
                for (int j = 0; j < bitsPerChar && i + j < a.Length; j++)
                {
                    if (a[i + j])
                    {
                        b |= (byte)(1 << j);
                    }
                }
                sb.Append((char)b);
            }
            return sb.ToString();
        }

        public static char ToChar(this bool[] a)
        {
            if (a.Length > 8)
            {
                throw new ArgumentException("Boolean array too long to fit in a byte.");
            }

            byte b = 0;
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i])
                {
                    b |= (byte)(1 << i);
                }
            }
            return (char)b;
        }
    }
}
