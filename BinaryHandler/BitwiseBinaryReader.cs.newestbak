using D2SLib2.Structure;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace D2SLib2.BinaryHandler
{
    public class BitwiseBinaryReader
    {
        public bool[] bitArray { get; private set; }
        public int bitPosition { get; private set; } = 0;

        public BitwiseBinaryReader(string filePath)
        {
            byte[] byteArray = File.ReadAllBytes(filePath);
            bitArray = new bool[byteArray.Length * 8];
            bitPosition = 0;

            for (int i = 0; i < byteArray.Length; i++)
            {
                byte b = byteArray[i];
                for (int j = 0; j < 8; j++)
                {
                    bitArray[i * 8 + j] = (b & (1 << (7 - j))) != 0;
                }
            }
            byte[] bytes_Converted = bitArray.ToBytes();
        }

        public BitwiseBinaryReader(bool[] newBitArray)
        {
            bitArray = newBitArray;
            bitPosition = 0;
        }

        // Read one bit
        public bool ReadBit()
        {
            if (bitPosition >= bitArray.Length)
            {
                throw new InvalidOperationException("End of file reached");
            }
            return bitArray[bitPosition++];
        }

        public bool PeekBit()
        {
            if(bitPosition >= bitArray.Length)
            {
                throw new InvalidOperationException("End of file reached");
            }
            return bitArray[bitPosition];
        }

        public bool[] ReadBits(int numBits)
        {
            if (numBits < 1)
            {
                throw new ArgumentException("Invalid number of bits");
            }

            if (bitPosition + numBits > bitArray.Length)
            {
                throw new InvalidOperationException("End of file reached");
            }

            bool[] result = new bool[numBits];
            for (int i = 0; i < numBits; i++)
            {
                result[i] = ReadBit();
            }
            return result;
        }

        public bool[] PeekBits(int numBits)
        {
            if(numBits < 1)
            {
                throw new ArgumentException("Invalid number of bits");
            }
            if(bitPosition + numBits < bitArray.Length)
            {
                throw new InvalidOperationException("End of file reached");
            }
            bool[] result = new bool[numBits];
            for(int i=0;i<numBits;i++)
            {
                result[i] = PeekBit();
            }
            return result;
        }

        public void SetBitPosition(int newBitPosition) => bitPosition = newBitPosition;
        public void Align() => bitPosition = (bitPosition + 7) & ~7;
    }

    public static class BitArrayExtensions
    {
        public static byte ToByte(this bool[] a)
        {
            return (byte)a.Select((b, i) => b ? 1 << (a.Length - 1 - i) : 0).Sum();
        }

        public static byte[] ToBytes(this bool[] a)
        {
            int numBytes = (a.Length + 7) / 8; // Calculate total bytes needed
            byte[] result = new byte[numBytes];

            for (int i = 0; i < a.Length; i++)
            {
                if (a[i])
                    result[i / 8] |= (byte)(1 << (7 - i % 8));
            }

            return result;
        }

        public static UInt16 ToUInt16(this bool[] a)
        {
            return (UInt16)a.Select((b, i) => b ? 1 << (a.Length - 1 - i) : 0).Sum();
        }

        public static UInt32 ToUInt32(this bool[] a)
        {
            return (UInt32)a.Select((b, i) => b ? 1 << (a.Length - 1 - i) : 0).Sum();
        }

        public static UInt64 ToUInt64(this bool[] a)
        {
            return (UInt64)a.Select((b, i) => b ? 1 << (a.Length - 1 - i) : 0).Sum();
        }


        public static string To_String(this bool[] a, int bitsPerChar = 8)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < a.Length; i += bitsPerChar)
            {
                byte b = 0;
                for (int j = 0; j < bitsPerChar && i + j < a.Length; j++)
                {
                    if (a[i + j])
                    {
                        b |= (byte)(1 << (7 - j));
                    }
                }
                sb.Append((char)b);
            }
            return sb.ToString();
        }

        public static char ToChar(this bool[] a)
        {
            if (a.Length > 8)
            {
                throw new ArgumentException("Boolean array too long to fit in a byte.");
            }

            byte b = 0;
            for (int i = 0; i < a.Length; i++)
            {
                if (a[i])
                {
                    b |= (byte)(1 << (7 - i));
                }
            }
            return (char)b;
        }
    }
}
